// Ferry loading // PC/ultraviolet A IDs: 111106/10261, popularity: B, success rate: Low Level: 3 // verdict: accepted // submission date: 2011-10-15 // UV Run Time: 0.536 s /// copyright (c) 2011, Qiu. Metaphysis # Yeah dot net /// [solution] // The use of violence law is obviously not feasible here (if the test data is weak, try it ), however, the number of vehicles in this question is as high as two hundred, and the computing time at a certain number is enough for you (but it is very interesting that you can barely pass through the backtracking method. It can be seen that the test data is not very strong, if you use the Backtracking Method, when the vehicle length is less than the free space of a certain Lane, you can place it in this lane and continue to trace back, however, this method must be used to effectively record the accessed status. Otherwise, the AC cannot be used within the specified time, which can be achieved through the set/in STL ). //// The greedy method is not applicable here. If you use a policy that always puts a vehicle in a large road, the inverse example is as follows: /// 50 // 2000 // 3000 // 1000 // 1000 // 1500 // 700 // 800 // if it is first placed in lane, if the vehicle body length is smaller than the spare length of lane A, the vehicle will be placed in lane A. The inverse example is as follows: //// 6 // 200 // 200 // 400 // 400 // dynamic planning is not feasible? The question requires to use two fixed length lanes to load more vehicles as much as possible. The length of the vehicle and the length of the vehicle cannot exceed the length of the lane. The length of the vehicle and the length of each lane are both an integer. If the length of the lane is long and N vehicles exist, the maximum number of ships is required. // J (0 <= j <= N ), so that J cars can be placed in two long lanes. Assuming that the number of boarding vehicles has reached the maximum number J, the length of the first J is sum [J], and the length of the vehicle in the left lane is l, if sum [J] = L, // indicates that all J vehicles can be placed in one driveway, otherwise, vehicles with the length of sum [J]-l must be placed in another lane. // You can set up an array to record the length of the left-side vehicle (m) after boarding an I-car as memo [I] [M]. the length of the vehicle on the right must be sum [I]-m, which is recorded as memo [I] [sum [I]-M]. If both of them can be placed, all are true, the initial condition is // memo [0] [0] = true. the maximum possible I is obtained from the bottom-up DP when memo [I] [length] = true. # Include <iostream> # include <algorithm> # include <cstring> # include <set> using namespace STD; # define maxn 201 # define maxl 100001 # define empty (-1) // Lane status class. Current indicates the number of vehicles that have been boarded, left indicates the remaining space in the left lane, and right indicates the number of remaining spaces in the right lane. Class state {public: int current, left, right; State () {} state (INT incurrent, int inleft, int inright) {current = incurrent; left = inleft; right = inright ;}~ State () {} bool operator <(const State & Other) const {return (current = Other. Current? (Left = Other. Left? Right <Other. right: Left <Other. left): Current <Other. current);} bool operator = (const State & Other) const {return (current = Other. current & left = Other. left & Right = Other. right) ;}}; set <State> cache; bool port [maxn + 1], answer [maxn + 1]; int cars [maxn + 1], ncars, maxcars; // The backtracking method is used to solve the problem. Current indicates the number of the vehicle to be boarded, left indicates the remaining space in the left lane, and right indicates the remaining space in the right/side lane. Void backtrack (INT current, int left, int right) {// if this status does not exist in the current cache, the status is put into the cache. If (cache. count (State (current, left, right)> 0) return; cache. insert (State (current, left, right); // obtain the length of the current car body. If all vehicles have been boarded, it indicates that the driveway can accommodate all vehicles. If the length of the current vehicle is greater than the remaining space of the two lanes, then, compare whether the current boarding quantity is greater than the current maximum number of boarding/vehicles found. Int carlength = cars [current]; If (current> ncars | carlength> MAX (left, right) {If (current-1)> maxcars) {maxcars = Current-1; memcpy (answer, port, sizeof (port);} return ;}// backtracking. If (carlength <= left) {port [current] = true; backtrack (current + 1, left-carlength, right);} If (carlength <= right) {port [current] = false; backtrack (current + 1, left, right-carlength) ;}} void solve_by_backtrack (void) {INT cases, ferrylength, carlength; bool printboredblankline = false; CIN> cases; while (cases --) {If (printboredblankline) cout <Endl; elseprintboredblankline = true; CIN> ferrylength; Ferrylength * = 100; ncars = 1; while (CIN> carlength, carlength) {If (ncars <maxn) cars [ncars ++] = carlength;} ncars --; maxcars = 0; cache. clear (); backtrack (1, ferrylength, ferrylength); cout <maxcars <Endl; For (INT I = 1; I <= maxcars; I ++) cout <(answer [I]? "Port": "starboard") <Endl ;}} bool memo [maxn + 1] [maxl + 1]; int choice [maxn + 1] [maxl + 1]; int sumlength [maxn + 1]; void solve_by_dynamic_programming (void) {INT cases, ferrylength, carlength; bool printboredblankline = false; CIN> cases; while (cases --) {If (printboredblankline) cout <Endl; elseprintboredblkline = true; CIN> ferrylength; ferrylength * = 100; ncars = 1; sumlength [0] = 0; while (CIN> Carlength, carlength) {If (ncars <maxn) {cars [ncars] = carlength; sumlength [ncars] = sumlength [ncars-1] + carlength; ncars ++ ;}} ncars --; pair <int, int> longest; memset (memo, false, sizeof (Memo); memset (choice, empty, sizeof (choice )); memo [0] [0] = true; For (INT I = 0; I <ncars; I ++) for (Int J = 0; j <= ferrylength; j ++) if (memo [I] [J]) {If (J + cars [I + 1]) <= ferrylength) {memo [I + 1] [J + cars [I + 1]] = True; choice [I + 1] [J + cars [I + 1] = 1; longest = make_pair (I + 1, J + cars [I + 1]);} If (sumlength [I]-J + cars [I + 1]) <= ferrylength) {memo [I + 1] [J] = true; choice [I + 1] [J] = 0; longest = make_pair (I + 1, J );}} cout <longest. first <Endl; string solution; For (INT I = longest. first, j = longest. second; I> 0 & choice [I] [J]! = Empty; I --) {solution = (choice [I] [J]? "Port \ n": "starboard \ n") + solution; If (choice [I] [J]) J-= cars [I];} cout <solution ;}int main (int ac, char * AV []) {// Backtracking Method, unsatisfactory, and ultraviolet a rt: 2.404 S. // Solve_by_backtrack (); // dynamic planning, ultraviolet a rt: 0.536 S. Solve_by_dynamic_programming (); Return 0 ;}